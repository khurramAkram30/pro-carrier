import { ThirdPartySoapConnector } from '../../../src/third-party-soap-connector/connector/third-party-soap-connector';
import { join } from 'path';
import { ThirdPartySoapRequest } from '../../../src/third-party-soap-connector/request/third-party-soap-request';

describe('Handling SOAP headers', () => {
    let connector: ThirdPartySoapConnector;

    beforeEach(async () => {
        connector = new ThirdPartySoapConnector();

        const wsdlPath = join(__dirname, './example-service.wsdl');
        await connector.Initialize(wsdlPath);
    });

    test('Calling GetSoapHeaders after using SetSoapHeaders should return the set headers', () => {
        // Arrange
        const headers = {
            'header1': 'value1',
            'header2': 'value2'
        };

        connector.SetSoapHeaders(headers);

        // Act
        const retrievedHeaders = connector.GetSoapHeaders();

        // Assert
        expect(retrievedHeaders).toEqual(headers);
    });

    test('Calling GetSoapHeaders after using UpdateSoapHeader should return an updated list of headers', () => {
        // Arrange
        const headers = {
            'header1': 'value1',
            'header2': 'value2'
        };

        connector.SetSoapHeaders(headers);
        connector.UpdateSoapHeader('header2', 'updatedValue2');

        // Act
        const retrievedHeaders = connector.GetSoapHeaders();

        // Assert
        expect(retrievedHeaders).toStrictEqual({
            'header1': 'value1',
            'header2': 'updatedValue2'
        });
    });

    test('Calling UpdateSoapHeader with a non-existing header should add the header', () => {
        // Arrange
        const headers = {
            'header1': 'value1',
            'header2': 'value2'
        };

        connector.SetSoapHeaders(headers);
        connector.UpdateSoapHeader('header3', 'value3');

        // Act
        const retrievedHeaders = connector.GetSoapHeaders();

        // Assert
        expect(retrievedHeaders).toStrictEqual({
            'header1': 'value1',
            'header2': 'value2',
            'header3': 'value3'
        });
    });
});

describe('Calling methods on unitialized client should throw an exception', () => {
    let connector: ThirdPartySoapConnector;

    beforeEach(() => {
        connector = new ThirdPartySoapConnector();
    });

    test('Calling AddCustomNamespaceToEnvelope should throw an exception', () => {
        // Arrange
        const name = 'name';
        const value = 'value';

        // Act & Assert
        expect(() => connector.AddCustomNamespaceToEnvelope(name, value))
            .toThrowError('Tried to add custom namespace to envelope without initializing the client.');
    });

    test('Calling SetSoapHeaders should throw an exception', () => {
        // Arrange
        const headers = {
            'header1': 'value1',
            'header2': 'value2'
        };

        // Act & Assert
        expect(() => connector.SetSoapHeaders(headers)).toThrowError('Tried to set SOAP headers without initializing the client.');
    });

    test('Calling UpdateSoapHeader should throw an exception', async () => {
        // Arrange
        const key = 'key';
        const value = 'value';

        // Act & Assert
        expect(() => connector.UpdateSoapHeader(key, value))
            .toThrowError('Tried to set SOAP headers without initializing the client.');
    });

    test('Calling GetSoapHeaders should throw an exception', async () => {
        // Act & Assert
        expect(() => connector.GetSoapHeaders())
            .toThrowError('Tried to get SOAP headers without initializing the client.');
    });

    test('Calling SendRequest should throw an exception', async () => {
        // Arrange
        const request = new ThirdPartySoapRequest<unknown>();

        // Act & Assert
        await expect(connector.SendRequest(request))
            .rejects
            .toThrowError('Tried to send a SOAP request without initializing the client.');
    });
});