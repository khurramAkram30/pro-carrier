"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThirdPartyConnectorAuthentication = void 0;
const request_expected_statuses_1 = require("../request-expected-statuses");
const logic_helper_1 = require("../../../logic-helper");
class ThirdPartyConnectorAuthentication {
    /**
     * Decorator can be used as a auto auth refresh behaviour.
     * @param base your master third party connector that wish you to execute
     * @param refreshAuthProcess determinate when and how to refresh auth - it might be implementation for bearer token, basic auth etc.
     * @param unauthorizedStatuses specified statuses codes that suggest to execute reauth attempt implementation.
     */
    constructor(base, refreshAuthProcess, unauthorizedStatuses) {
        this.base = base;
        this.refreshAuthProcess = refreshAuthProcess;
        this.unauthorizedStatuses = unauthorizedStatuses;
    }
    /**
     * Method checks if is required to refresh auth before make a call to carrier API.
     * Also, if the API return specify status code or the refresh is required then implementation makes it for you.
     * Out of the box method supports save logs and handling errors
     * Also you can provide expected status codes for success or fail behaviour
     * @param request ThirdPartyRequest
     * @param requestExpectedStatuses RequestExpectedStatuses
     */
    async SendRequestWithExpectedStatuses(request, requestExpectedStatuses) {
        let isAuthRequired = false;
        try {
            await this.HandleAuthLogic(request);
            return await this.base.SendRequestWithExpectedStatuses(request, requestExpectedStatuses);
        }
        catch (error) {
            this.unauthorizedStatuses.forEach(status => {
                var _a;
                if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes(`Status code: ${status}`)) {
                    isAuthRequired = true;
                }
            });
        }
        finally {
            if (isAuthRequired) {
                await this.ForceAuthRefresh(request);
            }
        }
        return await this.base.SendRequestWithExpectedStatuses(request, requestExpectedStatuses);
    }
    /**
     * Method checks if is required to refresh auth before make a call to carrier API.
     * Also, if the API return specify status code or the refresh is required then implementation makes it for you.
     * Out of the box method supports save logs and handling errors
     * @param request ThirdPartyRequest
     */
    async SendRequest(request) {
        return await this.SendRequestWithExpectedStatuses(request, new request_expected_statuses_1.RequestExpectedStatusesNullObject());
    }
    async HandleAuthLogic(request) {
        (0, logic_helper_1.LogInfo)(`${this.base.CarrierName} module. Check if auth refresh is required.`);
        if (this.refreshAuthProcess.IsRefreshRequired()) {
            await this.ForceAuthRefresh(request);
        }
    }
    async ForceAuthRefresh(request) {
        (0, logic_helper_1.LogInfo)(`${this.base.CarrierName} module. Refreshing auth.`);
        const refreshResponse = await this.base.SendRequest(this.refreshAuthProcess.RefreshBehaviour());
        if (!refreshResponse) {
            (0, logic_helper_1.LogInfo)(`${this.base.CarrierName} module. Refresh auth might failed. Response is empty.`);
        }
        (0, logic_helper_1.LogInfo)(`${this.base.CarrierName} module. Apply refreshed auth.`);
        this.refreshAuthProcess.ApplyRefreshBehaviour(refreshResponse, request);
    }
}
exports.ThirdPartyConnectorAuthentication = ThirdPartyConnectorAuthentication;
//# sourceMappingURL=third-party-connector-authentication.js.map