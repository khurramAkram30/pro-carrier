"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetSeparateZPLLabelDocument = exports.GetPDFDocument = exports.GetSeparatePDFLabelDocument = exports.GetRotatedBase64PNGFromBase64PNGLabel = exports.GetRotatedBase64PDFFromBase64PDFLabel = exports.RotateLabelFromBase64 = void 0;
const tslib_1 = require("tslib");
const pdf_lib_1 = require("pdf-lib");
const sharp_1 = tslib_1.__importDefault(require("sharp"));
const connect_carrier_api_1 = require("@shipengine/connect-carrier-api");
const logic_helper_1 = require("../logic-helper");
const RotateLabelFromBase64 = async (base64string, documentFormat, angle) => {
    switch (documentFormat) {
        case connect_carrier_api_1.DocumentFormat.Pdf:
            return await (0, exports.GetRotatedBase64PDFFromBase64PDFLabel)(base64string, angle);
        case connect_carrier_api_1.DocumentFormat.Png:
            return await (0, exports.GetRotatedBase64PNGFromBase64PNGLabel)(base64string, angle);
        default:
            (0, logic_helper_1.HandleError)(`Document format ${documentFormat} is not supported`);
    }
    return Promise.resolve('');
};
exports.RotateLabelFromBase64 = RotateLabelFromBase64;
const GetRotatedBase64PDFFromBase64PDFLabel = async (base64String, degreesAngle) => {
    const pdfBytes = Buffer.from(base64String, 'base64');
    const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBytes);
    const pageCount = pdfDoc.getPageCount();
    for (let pageIndex = 0; pageIndex < pageCount; pageIndex++) {
        const page = pdfDoc.getPage(pageIndex);
        page.setRotation((0, pdf_lib_1.degrees)(degreesAngle));
    }
    const modifiedPdfBytes = await pdfDoc.save();
    return Buffer.from(modifiedPdfBytes).toString('base64');
};
exports.GetRotatedBase64PDFFromBase64PDFLabel = GetRotatedBase64PDFFromBase64PDFLabel;
const GetRotatedBase64PNGFromBase64PNGLabel = async (base64String, rotationAngle) => {
    const inputBuffer = Buffer.from(base64String, 'base64');
    const outputBuffer = await (0, sharp_1.default)(inputBuffer)
        .rotate(rotationAngle)
        .toBuffer();
    return outputBuffer.toString('base64');
};
exports.GetRotatedBase64PNGFromBase64PNGLabel = GetRotatedBase64PNGFromBase64PNGLabel;
/**
 * Method that separates multiple PDF labels
 * @param documentsData string that contains multiple labels
 */
const GetSeparatePDFLabelDocument = async (documentsData) => {
    const pdfDocument = await (0, exports.GetPDFDocument)(documentsData);
    return await SanitizePdfContent(pdfDocument);
};
exports.GetSeparatePDFLabelDocument = GetSeparatePDFLabelDocument;
const GetDocumentFromPDFFile = async (pdfDoc, indexOfRequiredPage) => {
    const copyPdfDocument = await pdf_lib_1.PDFDocument.create();
    const [pdfPage] = await copyPdfDocument.copyPages(pdfDoc, [indexOfRequiredPage]);
    copyPdfDocument.addPage(pdfPage);
    return await copyPdfDocument.saveAsBase64();
};
const GetPDFDocument = async (pdfResponse) => {
    return await pdf_lib_1.PDFDocument.load(pdfResponse, { updateMetadata: false });
};
exports.GetPDFDocument = GetPDFDocument;
const SanitizePdfContent = async (pdfDocument) => {
    const pdfContent = [];
    const packagePagesCount = pdfDocument.getPageCount();
    for (let packageDocumentIndex = 0; packageDocumentIndex < packagePagesCount; packageDocumentIndex++) {
        const document = await GetDocumentFromPDFFile(pdfDocument, packageDocumentIndex);
        pdfContent.push(document);
    }
    return pdfContent;
};
/**
 * Method that separates multiple ZPL labels by splitting them with delimiter that indicates the end of a label
 * @param documentsData ZPL string that contains multiple labels
 */
const GetSeparateZPLLabelDocument = (documentsData) => {
    const delimiter = '^XZ';
    const result = [];
    let indexOfDelimiter = documentsData.indexOf(delimiter);
    let lastIndex = 0;
    while (indexOfDelimiter !== -1) {
        const slice = documentsData.substring(lastIndex, indexOfDelimiter + delimiter.length);
        result.push(slice);
        lastIndex = indexOfDelimiter + delimiter.length;
        indexOfDelimiter = documentsData.indexOf(delimiter, lastIndex);
    }
    if (lastIndex < documentsData.length) {
        result.push(documentsData.substring(lastIndex));
    }
    return result;
};
exports.GetSeparateZPLLabelDocument = GetSeparateZPLLabelDocument;
//# sourceMappingURL=label-helper.js.map