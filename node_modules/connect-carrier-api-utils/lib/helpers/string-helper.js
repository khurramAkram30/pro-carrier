"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayBufferToBase64 = exports.StringToBase64 = exports.FormatUtcDate = exports.CheckIfMandatoryParametersAreProvided = exports.GetSafeString = exports.FormatUrl = exports.CheckAndSubstringText = exports.GetFirstNotEmpty = void 0;
const logic_helper_1 = require("../logic-helper");
/**
 * Return first not empty string from the collection
 * @param args collection of the words
 */
const GetFirstNotEmpty = (...args) => {
    for (const arg of args) {
        if (arg) {
            return arg;
        }
    }
    return '';
};
exports.GetFirstNotEmpty = GetFirstNotEmpty;
/**
 * Method return new string cut to specify maximum length
 * @param value string to cut
 * @param maximumLength expected length
 */
const CheckAndSubstringText = (value, maximumLength) => {
    if (!maximumLength) {
        return value;
    }
    if (!value) {
        return '';
    }
    if (value.length < maximumLength) {
        return value;
    }
    return value.substring(0, maximumLength);
};
exports.CheckAndSubstringText = CheckAndSubstringText;
/**
 * Concat URL and resource.
 * @param apiUrl API url
 * @param resourceUrl resource
 */
const FormatUrl = (apiUrl, resourceUrl) => {
    if (resourceUrl.startsWith('/')) {
        resourceUrl = resourceUrl.slice(1, resourceUrl.length);
    }
    return apiUrl.endsWith('/') ? `${apiUrl}${resourceUrl}` : `${apiUrl}/${resourceUrl}`;
};
exports.FormatUrl = FormatUrl;
/**
 * Get safe string. In case a value is undefined return empty string.
 * @param value
 */
const GetSafeString = (value) => {
    return value !== null && value !== void 0 ? value : '';
};
exports.GetSafeString = GetSafeString;
/**
 * Method dedicated to check list of the parameters if are provided. In case of missing value error is thrown.
 * @param params collection of combine parameter name and value
 */
const CheckIfMandatoryParametersAreProvided = (...params) => params.forEach((param) => {
    if (!param.parameterValue) {
        (0, logic_helper_1.HandleError)(`Mandatory parameter ${param.parameterName} is not provided.`);
    }
});
exports.CheckIfMandatoryParametersAreProvided = CheckIfMandatoryParametersAreProvided;
/**
 *  Formats the given date to the given format converted to UTC time zone
 *
 *   Mapped values:
 *
 *     yyyy - full year
 *
 *     yy - simplified year ex. 2023 - 23
 *
 *     MM - month
 *
 *     dd - day
 *
 *     HH - hour
 *
 *     mm - minutes
 *
 *     ss - seconds
 *
 *     fff - milliseconds
 *
 *     ff - milliseconds with 2 digits
 *
 * @param date - date object with given date which will be convert to UTC time zone
 * @param  format - string of format ex. 'yyyyMMddHHmmss'
 *
 * @remarks All values besides year are padded to 2 digit format to keep leading zeros. Ex. June - 06
 *
 * @returns Date in UTC time zone formatted to string
 *  */
const FormatUtcDate = (date, format) => {
    const map = {
        dd: PadTo2Digits(date.getUTCDate()),
        MM: PadTo2Digits(date.getUTCMonth() + 1),
        yy: date.getUTCFullYear().toString().slice(-2),
        yyyy: date.getUTCFullYear().toString(),
        HH: PadTo2Digits(date.getUTCHours()),
        mm: PadTo2Digits(date.getMinutes()),
        ss: PadTo2Digits(date.getUTCSeconds()),
        fff: date.getUTCMilliseconds().toString(),
        ff: PadTo2Digits(date.getUTCMilliseconds())
    };
    return format.replace(/dd|MM|yyyy|yy|HH|mm|ss|fff|ff/gi, (matched) => map[matched]);
};
exports.FormatUtcDate = FormatUtcDate;
const PadTo2Digits = (num) => {
    return num.toString().padStart(2, '0');
};
/**
 * Encode string to base64.
 *
 * @param value string to encode
 *
 * @returns base64 string
 */
const StringToBase64 = (value) => Buffer.from(value, 'binary').toString('base64');
exports.StringToBase64 = StringToBase64;
/**
 * Encode provided ArrayBuffer to base64 string.
 *
 * @param buffer ArrayBuffer to encode
 *
 * @returns base64 string
 */
const ArrayBufferToBase64 = (buffer) => {
    if (!buffer) {
        return '';
    }
    const nodeBuffer = Buffer.from(buffer);
    return nodeBuffer.toString('base64');
};
exports.ArrayBufferToBase64 = ArrayBufferToBase64;
//# sourceMappingURL=string-helper.js.map