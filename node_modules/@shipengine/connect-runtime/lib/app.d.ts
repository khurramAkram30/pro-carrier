import type { Request } from 'express';
/** @description The Http Verb associated with a given call */
export declare enum Method {
    POST = "post",
    GET = "get",
    PUT = "put",
    PATCH = "patch",
    DELETE = "delete"
}
/**
 * @description This regex is used to validation ApiCode fields inside of app metadata definitions.
 * When the ALLOW_LEGACY_API_CODES flag is set, capital letters will pass validation, but otherwise
 * we reject them so that developers are encouraged to use proper snake case for their codes.
 */
export declare const ApiCodeRegex: RegExp;
export declare const ApiCodeValidationMessage = "ApiCode pattern of: snake case, alphanumeric. If your integration contains legacy metadata you can try running again with ALLOW_LEGACY_API_CODES=1 to use the legacy";
/** @description The definition for a route that will serve up the contents of a file */
export interface FileRoute {
    /** @description The file that should be sent to the client. If this is set, handler will not be used. */
    file: string | ((req: Request) => string | Promise<string>);
}
export declare function mapExtensions(extensions: Record<string, Handler> | undefined): [Method, string, ((req: any) => any | Promise<any>) | undefined][];
export type Handler = (req: any) => any | Promise<any> | AsyncGenerator<any>;
/** @description The definition for a route and how it will be handled */
export interface HandlerRoute {
    /** @description The method that will be called to handle this request */
    handler?: Handler;
    /** @description The optional method used to validate the response for this route. Used for warning purposes. */
    validateResponse?: (response: any) => string[] | undefined;
}
/** @description The definition for all types of routes */
export type Route = {
    /** @description The path to the endpoint you wish to expose @example "/CreateLabel", "/sales_orders_export" */
    path: string;
    /** @description The http verb used for this endpoint @example "GET", "POST" */
    method: Method;
} & (FileRoute | HandlerRoute);
/** @description This contains the logo and icon for an individual branded entity */
export interface BrandedImages {
    /** @description The id associated with the branded item (typically the carrier id, or ordersource id) */
    id: string;
    /** @description The full path to the logo file */
    logo: string;
    /** @description The full path to the icon file */
    icon: string;
}
export interface RequestResponseInfo {
    /** HTTP request, as a string */
    request?: string;
    /** HTTP request headers */
    request_headers?: Record<string, string>;
    /** HTTP request as a string */
    response?: string;
    /** HTTP response headers */
    response_headers?: Record<string, string>;
}
/** @description This exposes the base needs for an app to be successful in the generic connect runtime */
export interface App {
    /** @description The routes your application should expose */
    routes: Route[];
    /** @description The metadata associated with your application */
    data: any;
    /** @description A method that returns an array of images associated with branded entities within your app */
    getImages: () => BrandedImages[];
    /** @description A method that gets additional info to log from the request when logging */
    getAdditionalContext?: (req: Request) => Record<string, string>;
    redactExternalRequest?: (req: RequestResponseInfo) => Promise<RequestResponseInfo> | RequestResponseInfo;
    getAdditionalVersionInfo?: () => Promise<Record<string, string>> | Record<string, string>;
    /** @description String containing yaml or json file to display with redoc  */
    redoc?: string;
}
