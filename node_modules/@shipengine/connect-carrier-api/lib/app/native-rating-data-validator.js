"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRatingData = exports.isDataValidationError = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const getDuplicateKeys = (dataArray) => {
    let keys = [];
    let keyContainer = Object.create(null);
    dataArray.forEach((arrayItem) => {
        if (arrayItem['key']) {
            if (keyContainer[arrayItem['key']]) {
                keys.push(arrayItem['key']);
            }
            else {
                keyContainer[arrayItem['key']] = true;
            }
        }
    });
    return keys.length > 0 ? keys : undefined;
};
const validate = (dataFilePath, dataType) => {
    if ((0, fs_1.existsSync)(dataFilePath)) {
        const dataBuffer = (0, fs_1.readFileSync)(dataFilePath);
        const json = JSON.parse(dataBuffer.toString());
        const data = json?.[dataType] || [];
        const duplicates = getDuplicateKeys(data);
        if (duplicates) {
            return {
                message: `${dataType} in ${dataFilePath} contains duplicate keys.`,
                duplicateKeys: duplicates,
            };
        }
    }
};
const isDataValidationError = (errors) => errors !== undefined;
exports.isDataValidationError = isDataValidationError;
const validateRatingData = (carrier) => {
    let errors = [];
    let basePath = carrier.NativeRating?.Path ?? '';
    let error = validate((0, path_1.resolve)(basePath, 'zones.json'), 'zones');
    if (error)
        errors.push(error);
    carrier.NativeRating?.RateCards?.forEach((rateCard) => {
        error = validate((0, path_1.resolve)(basePath, rateCard.Id, 'rates.json'), 'rates');
        if (error)
            errors.push(error);
        error = validate((0, path_1.resolve)(basePath, rateCard.Id, 'variables.json'), 'variables');
        if (error)
            errors.push(error);
    });
    return errors.length > 0 ? errors : undefined;
};
exports.validateRatingData = validateRatingData;
//# sourceMappingURL=native-rating-data-validator.js.map