"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.displayAccountInfo = exports.getSupportedCountries = exports.isAppFailedToDeployError = exports.isAppFailedToPackageError = void 0;
const tslib_1 = require("tslib");
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const log_symbols_1 = tslib_1.__importDefault(require("log-symbols"));
const path_1 = tslib_1.__importDefault(require("path"));
const types_1 = require("./types");
const watch_deployment_1 = require("./publish-app/watch-deployment");
const chalk_1 = require("chalk");
const parse_deployment_errors_1 = tslib_1.__importDefault(require("./utils/parse-deployment-errors"));
const cli_table_1 = tslib_1.__importDefault(require("cli-table"));
const create_or_find_test_account_1 = require("./utils/create-or-find-test-account");
const update_app_id_1 = require("./update-app-id");
const app_loader_1 = require("./app-loader");
class AppFailedToPackageError extends Error {
    code;
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
        this.name = AppFailedToPackageError.name; // stack traces display correctly now
        this.code = 'APP_FAILED_TO_PACKAGE';
    }
}
class AppFailedToDeployError extends Error {
    code;
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
        this.name = AppFailedToPackageError.name; // stack traces display correctly now
        this.code = 'APP_FAILED_TO_DEPLOY';
    }
}
function isAppFailedToPackageError(obj) {
    if (typeof obj === 'object' && obj !== null) {
        const code = Reflect.get(obj, 'code');
        return code === 'APP_FAILED_TO_PACKAGE';
    }
    return false;
}
exports.isAppFailedToPackageError = isAppFailedToPackageError;
function isAppFailedToDeployError(obj) {
    if (typeof obj === 'object' && obj !== null) {
        const code = Reflect.get(obj, 'code');
        return code === 'APP_FAILED_TO_DEPLOY';
    }
    return false;
}
exports.isAppFailedToDeployError = isAppFailedToDeployError;
const getSupportedCountries = (app) => {
    const unitedStates = ['US'];
    if (app.getSupportedCountries) {
        const supportedCountries = app.getSupportedCountries() || unitedStates;
        return supportedCountries;
    }
    if (app.type === app_loader_1.AppType.Carrier && app.deploymentType === app_loader_1.DeploymentType.LegacyConnectCarrier) {
        const countries = app.deliveryServices
            ?.map((service) => service?.availableCountries)
            ?.flat();
        const uniqueCountries = [...new Set(countries)].filter((country) => country);
        if (uniqueCountries.length >= 1) {
            return uniqueCountries;
        }
    }
    return unitedStates;
};
exports.getSupportedCountries = getSupportedCountries;
async function publishApp(tarballName, client, { noWatch = false }, appDir = process.cwd()) {
    cli_ux_1.default.action.start('Publishing app');
    let supportedCountries = [];
    let newDeployment;
    let platformApp;
    try {
        const app = await (0, app_loader_1.loadApp)(appDir);
        // Update Package.json AppId if it isn't present and has been published
        try {
            const deployedApp = await client.apps.getByIdOrName(app.manifest.name, app.manifest.appId);
            if (!app.manifest.appId) {
                (0, update_app_id_1.updateAppId)(path_1.default.join(appDir, 'package.json'), deployedApp.id);
                app.manifest.appId = deployedApp.id;
                console.log((0, chalk_1.yellow)(`Updated package.json set appId to ${deployedApp.id}`));
            }
        }
        catch { }
        supportedCountries = (0, exports.getSupportedCountries)(app);
        const pathToTarball = path_1.default.join(appDir, tarballName);
        platformApp = await client.apps.findOrCreateApp({
            appId: app.manifest.appId || app.providerId,
            name: app.manifest.name,
            type: app.deploymentType,
        });
        // Check to see if deploymentType has changed
        const appDetailsChanged = platformApp.type !== app.deploymentType || platformApp.name !== app.manifest.name;
        if (appDetailsChanged) {
            console.log((0, chalk_1.yellow)(`Updating name to ${app.manifest.name} deployment type to ${app.deploymentType}`));
            try {
                await client.apps.update(platformApp.id, app.manifest.name, app.deploymentType);
                console.log((0, chalk_1.green)('App data updated'));
            }
            catch (err) {
                console.log((0, chalk_1.yellow)(`Warning: failed to update app definition. Error: ${err}`));
            }
        }
        newDeployment = await client.deployments.create({
            appId: platformApp.id,
            pathToTarball: pathToTarball,
        });
    }
    catch (error) {
        const err = error;
        const errorMessage = `There was an error deploying your app to the connect platform: ${err.message}`;
        throw new AppFailedToDeployError(errorMessage);
    }
    finally {
        // Delete the package tarball
        await fs_1.default.promises.unlink(tarballName);
    }
    cli_ux_1.default.action.stop(`${log_symbols_1.default.success}`);
    if (!noWatch) {
        const deployment = await (0, watch_deployment_1.watchDeployment)(newDeployment, platformApp, client);
        if (deployment.status === types_1.DeploymentStatus.Error) {
            console.log((0, chalk_1.red)(`Your app encountered an error during deployment ${log_symbols_1.default.error} `));
            const errors = (0, parse_deployment_errors_1.default)(deployment);
            if (errors.length === 0) {
                console.log((0, chalk_1.red)(`- This error was most likely caused by an issue in the Connect Platform and not your application`));
                console.log((0, chalk_1.red)(`- If the error persists, please contact Connect Support at connect@shipengine.com and include your app id ${platformApp.id}`));
            }
            else {
                errors.forEach((error) => {
                    console.log((0, chalk_1.red)(`- ${error}`));
                });
            }
        }
        else if (deployment.status === types_1.DeploymentStatus.Terminated) {
            console.log((0, chalk_1.red)('Your app was terminated '));
        }
        else {
            console.log((0, chalk_1.green)(`Your app was published successfully ${log_symbols_1.default.success} `));
            const accountInfo = await (0, create_or_find_test_account_1.createOrFindTestAccounts)(client, platformApp, supportedCountries);
            (0, exports.displayAccountInfo)(accountInfo);
        }
        return newDeployment;
    }
    const accountInfo = await (0, create_or_find_test_account_1.createOrFindTestAccounts)(client, platformApp, supportedCountries);
    (0, exports.displayAccountInfo)(accountInfo);
    return newDeployment;
}
exports.default = publishApp;
const displayAccountInfo = (accounts) => {
    console.log('Test your app with the accounts below:');
    accounts.forEach((account) => {
        const table = new cli_table_1.default();
        table.push({ 'Seller Country': [account.country] }, { Email: [account.email] }, { Password: [account.password] }, { 'Test URL': [account.testUrl ?? 'N/A'] });
        console.log(table.toString());
    });
};
exports.displayAccountInfo = displayAccountInfo;
//# sourceMappingURL=publish-app.js.map