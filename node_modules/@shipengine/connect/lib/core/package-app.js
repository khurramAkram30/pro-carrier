"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAppFailedToPackageError = exports.AppFailedToPackageError = exports.packageApp = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = tslib_1.__importDefault(require("util"));
const child_process_1 = require("child_process");
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const log_symbols_1 = tslib_1.__importDefault(require("log-symbols"));
const app_loader_1 = require("./app-loader");
const asyncExec = util_1.default.promisify(child_process_1.exec);
const isTypeScriptProject = (manifest) => {
    const dependencies = [
        ...Object.keys(manifest.dependencies || {}),
        ...Object.keys(manifest.devDependencies || {}),
    ];
    return dependencies.includes('typescript');
};
/**
 * This function is used for add all dependencies in the package.json app to the bundled dependencies property
 * and then running npm pack to create a tarball for deploying to the connect platform.
 */
async function packageApp(cwd) {
    const currentDir = cwd ? cwd : process.cwd();
    const packagePath = (0, path_1.join)(currentDir, 'package.json');
    const packageLockPath = (0, path_1.join)(currentDir, 'package-lock.json');
    const shrinkWrapPath = (0, path_1.join)(currentDir, 'npm-shrinkwrap.json');
    const packageLockExisted = (0, fs_1.existsSync)(packageLockPath);
    const shrinkWrapExisted = (0, fs_1.existsSync)(shrinkWrapPath);
    const pJsonBackup = (0, fs_1.readFileSync)(packagePath);
    cli_ux_1.default.action.start('Packaging app');
    const results = (0, fs_1.readFileSync)(packagePath, 'utf-8');
    const pjson = JSON.parse(results);
    const usesTypeScript = isTypeScriptProject(pjson);
    let fileName;
    try {
        if (usesTypeScript) {
            console.log('Transpiling TypeScript.');
            await asyncExec('npm run-script build', { cwd: currentDir });
        }
        try {
            const app = await (0, app_loader_1.loadApp)(currentDir);
            await app.prepackage?.({ package: pjson, path: currentDir });
            (0, fs_1.writeFileSync)(packagePath, JSON.stringify(pjson, undefined, 2));
        }
        catch (err) {
            throw new AppFailedToPackageError(`Error encountered prepackaging app: ${err.message}`);
        }
        try {
            await asyncExec('npm shrinkwrap', { cwd: currentDir });
        }
        catch (err) {
            throw new AppFailedToPackageError(`Error encountered running npm shrinkwrap: ${err.message}`);
        }
        const results = await asyncExec('npm pack', { cwd: currentDir });
        fileName = results.stdout;
    }
    catch (error) {
        const err = error;
        const errorMessage = `Unable to bundle dependencies and package app: ${err.message}`;
        throw new AppFailedToPackageError(errorMessage);
    }
    finally {
        // Restore the package.json backup
        (0, fs_1.writeFileSync)(packagePath, pJsonBackup);
        // Restore Lock File State
        // package-lock.json gets renamed to npm-shrinkwrap.json during npm shrinkwrap
        const shrinkWrapExists = (0, fs_1.existsSync)(shrinkWrapPath);
        if (shrinkWrapExists && packageLockExisted) {
            (0, fs_1.renameSync)(shrinkWrapPath, packageLockPath);
        }
        else if (!shrinkWrapExisted && shrinkWrapExists) {
            (0, fs_1.unlinkSync)(shrinkWrapPath);
        }
    }
    cli_ux_1.default.action.stop(`${log_symbols_1.default.success}`);
    return fileName.trim();
}
exports.packageApp = packageApp;
class AppFailedToPackageError extends Error {
    code;
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
        this.name = AppFailedToPackageError.name; // stack traces display correctly now
        this.code = 'APP_FAILED_TO_PACKAGE';
    }
}
exports.AppFailedToPackageError = AppFailedToPackageError;
function isAppFailedToPackageError(obj) {
    if (typeof obj === 'object' && obj !== null) {
        const code = Reflect.get(obj, 'code');
        return code === 'APP_FAILED_TO_PACKAGE';
    }
    return false;
}
exports.isAppFailedToPackageError = isAppFailedToPackageError;
//# sourceMappingURL=package-app.js.map