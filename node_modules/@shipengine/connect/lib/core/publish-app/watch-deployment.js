"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchDeployment = void 0;
const tslib_1 = require("tslib");
const types_1 = require("../types");
const util_1 = require("util");
const readline = tslib_1.__importStar(require("readline"));
const chalk_1 = require("chalk");
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const sleep = (0, util_1.promisify)(setTimeout);
function writeDeploymentInfo(deployment, count) {
    cli_ux_1.default.action.stop();
    if (count > 0) {
        readline.moveCursor(process.stdout, 0, -1);
    }
    readline.clearScreenDown(process.stdout);
    cli_ux_1.default.action.start(`watching app name: ${(0, chalk_1.green)(deployment.package.name)}, status: ${(0, chalk_1.green)(deployment.status)}`);
}
/**
 * Poll for the status of a deployment. It will keep deploying at the desired interval until one of the following status is returned:
 * - terminated
 * - running
 * - error
 */
async function watchDeployment(deployment, app, client) {
    let watchDeployment = deployment;
    let count = 0;
    while (watchDeployment.status === types_1.DeploymentStatus.Queued ||
        watchDeployment.status === types_1.DeploymentStatus.Building ||
        watchDeployment.status === types_1.DeploymentStatus.Deploying) {
        const updatedDeployment = await client.deployments.getById({
            deployId: deployment.deployId,
            appId: app.id,
        });
        writeDeploymentInfo(updatedDeployment, count);
        count++;
        watchDeployment = updatedDeployment;
        await sleep(5000);
    }
    return watchDeployment;
}
exports.watchDeployment = watchDeployment;
//# sourceMappingURL=watch-deployment.js.map