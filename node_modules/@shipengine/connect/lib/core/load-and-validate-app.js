"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInvalidAppError = void 0;
const app_loader_1 = require("./app-loader");
class InvalidAppError extends Error {
    errors;
    code;
    constructor(message, errors) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
        this.name = InvalidAppError.name; // stack traces display correctly now
        this.errors = errors;
        this.code = 'INVALID_APP';
    }
}
async function loadAndValidateApp(pathToApp) {
    try {
        const app = (await (0, app_loader_1.loadApp)(pathToApp));
        if (app.validate) {
            const errors = await app.validate();
            if (errors) {
                return Promise.reject(new InvalidAppError('Your app metadata is invalid', errors));
            }
        }
        return app;
    }
    catch (error) {
        const err = error;
        let errors = [];
        if (err.details) {
            const errorItems = err.details;
            errors = errorItems.map((item) => {
                return item.message;
            });
        }
        else {
            errors.push(err.message);
        }
        return Promise.reject(new InvalidAppError(err.message, errors));
    }
}
exports.default = loadAndValidateApp;
function isInvalidAppError(obj) {
    if (typeof obj === 'object' && obj !== null) {
        const code = Reflect.get(obj, 'code');
        if (code === 'INVALID_APP') {
            return true;
        }
    }
    return false;
}
exports.isInvalidAppError = isInvalidAppError;
//# sourceMappingURL=load-and-validate-app.js.map