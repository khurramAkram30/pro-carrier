"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const base_command_1 = tslib_1.__importDefault(require("../base-command"));
const login_1 = tslib_1.__importDefault(require("./login"));
const publish_app_1 = tslib_1.__importStar(require("../core/publish-app"));
const command_1 = require("@oclif/command");
const package_app_1 = require("../core/package-app");
const test_app_1 = tslib_1.__importDefault(require("../core/test-app"));
const unauthenticated_error_1 = require("../core/unauthenticated-error");
class Publish extends base_command_1.default {
    static description = 'Packages and publishes your app to the dev server';
    static examples = ['$ connect publish'];
    // TODO: come up with a convention for turning off spinners if the user desires
    // TODO: implement a quiet command?
    static flags = {
        help: command_1.flags.help({
            char: 'h',
            description: 'Show help for the publish command',
        }),
        'no-watch': command_1.flags.boolean({
            char: 'n',
            description: 'Does not track the status of the deployment',
        }),
        debug: command_1.flags.boolean({
            char: 'd',
            description: 'Show network debugging information',
            default: false,
            hidden: true,
        }),
    };
    async run() {
        // When the -h flag is present the following line halts execution
        const { flags } = this.parse(Publish);
        // Verify user is logged in
        try {
            await this.getCurrentUser(flags.debug);
        }
        catch (error) {
            if (error instanceof unauthenticated_error_1.UnauthenticatedError) {
                await login_1.default.run([]);
            }
            else {
                return this.error(error, {
                    exit: 1,
                });
            }
        }
        const apiClient = await this.apiClient(flags.debug);
        const pathToApp = process.cwd();
        const results = await (0, test_app_1.default)(pathToApp);
        if (results.failed > 0) {
            return this.exit(1);
        }
        try {
            const tarballName = await (0, package_app_1.packageApp)();
            await (0, publish_app_1.default)(tarballName, apiClient, {
                noWatch: flags['no-watch'],
            }, pathToApp);
        }
        catch (error) {
            if ((0, package_app_1.isAppFailedToPackageError)(error)) {
                return this.error(error.message, {
                    exit: 1,
                });
            }
            if ((0, publish_app_1.isAppFailedToDeployError)(error)) {
                return this.error(error.message, {
                    exit: 1,
                });
            }
            throw error;
        }
    }
}
exports.default = Publish;
//# sourceMappingURL=publish.js.map