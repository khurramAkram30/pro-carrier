"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const base_command_1 = tslib_1.__importDefault(require("../base-command"));
const command_1 = require("@oclif/command");
const login_1 = tslib_1.__importDefault(require("./login"));
const api_client_1 = require("../core/api-client");
const dip_log_helpers_1 = require("../core/utils/dip-log-helpers");
const app_loader_1 = require("../core/app-loader");
const log_types_1 = require("../core/types/log-types");
const unauthenticated_error_1 = require("../core/unauthenticated-error");
class Logs extends base_command_1.default {
    static description = 'Get the logs for your app';
    static flags = {
        help: command_1.flags.help({
            char: 'h',
            description: 'Show help for the logs command',
        }),
        debug: command_1.flags.boolean({
            char: 'd',
            description: 'Show network debugging information',
            default: false,
            hidden: true,
        }),
        lines: command_1.flags.string({
            char: 'l',
            default: '500',
            description: 'The number of lines of logs to show from the server, max of 1500',
        }),
        all: command_1.flags.boolean({
            char: 'a',
            default: true,
            description: 'This flag has been deprecated, all logs will now be returned by default.',
        }),
        format: command_1.flags.string({
            char: 'f',
            description: 'The format the logs get shown in',
            options: ['default', 'raw'],
            default: 'default',
        }),
        type: command_1.flags.string({
            char: 't',
            description: 'The type of logs to show',
            options: ['all', ...log_types_1.logTypes],
            default: 'all',
        }),
    };
    async run() {
        // When the -h flag is present the following line halts execution
        const { flags } = this.parse(Logs);
        // Verify user is logged in
        try {
            await this.getCurrentUser(flags.debug);
        }
        catch (error) {
            if (error instanceof unauthenticated_error_1.UnauthenticatedError) {
                await login_1.default.run([]);
            }
            else {
                return this.error(error, {
                    exit: 1,
                });
            }
        }
        try {
            const pathToApp = process.cwd();
            const app = await (0, app_loader_1.loadApp)(pathToApp);
            const apiClient = await this.apiClient(flags.debug);
            const platformApp = await apiClient.apps.getByIdOrName(app.manifest.name, app.manifest.appId);
            const paginatedDeployments = await apiClient.deployments.getAllForAppId(platformApp.id);
            const latestDeployment = paginatedDeployments.items[0];
            const logs = await apiClient.deployments.getLogsById({
                deployId: latestDeployment.deployId,
                appId: platformApp.id,
                type: flags.type,
            });
            if (flags.format !== 'raw') {
                const parsedLogs = (0, dip_log_helpers_1.parseDIPLogs)(logs, Number(flags.lines));
                parsedLogs.map((log) => this.log(log));
            }
            else {
                this.log(logs);
            }
        }
        catch (error) {
            switch (error.code) {
                case 'ERR_APP_ERROR':
                    return this.error('Error loading your app - please make sure you are in an app directory', {
                        exit: 1,
                    });
                case api_client_1.ApiClientErrors.NotFound:
                    return this.error('This app has not been published yet', {
                        exit: 1,
                    });
                default:
                    return this.error(error, {
                        exit: 1,
                    });
            }
        }
    }
}
exports.default = Logs;
//# sourceMappingURL=logs.js.map